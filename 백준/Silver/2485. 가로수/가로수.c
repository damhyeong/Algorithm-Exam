/**
    @Author : 공담형
    @Email : rhdwhdals8765@gmail.com
    @Github : https://github.com/damhyeong
    @Blog : https://codecreature.tistory.com

    "최소한의" 기능과 라이브러리를 사용하고, 나머지 기능을 직접 구현하기 때문에,

    다른 C 코드를 참조하시는 것이 좋습니다.

    블로그에서 다양한 컴퓨터 관점과 Computer Science 를 다루고 있으니 궁금하면 들러보셔요!

    참고로, AI 작성 글이 아니라, 진짜 공식문서 뒤져가면서 힘들게 얻은 지식을 나눠보려고 합니다.
*/

/**
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	128 MB	35395	15073	12493	43.371%

문제
---
직선으로 되어있는 도로의 한 편에 가로수가 임의의 간격으로 심어져있다.

KOI 시에서는 가로수들이 모두 같은 간격이 되도록 가로수를 추가로 심는 사업을 추진하고 있다.

KOI 시에서는 예산문제로 가능한 한 가장 적은 수의 나무를 심고 싶다.

편의상 가로수의 위치는 기준점으로 부터 떨어져 있는 거리로 표현되며,

가로수의 위치는 모두 양의 정수이다.

예를 들어, 가로수가 (1, 3, 7, 13)의 위치에 있다면 (5, 9, 11)의 위치에 가로수를 더 심으면 모든 가로수들의 간격이 같게 된다.

또한, 가로수가 (2, 6, 12, 18)에 있다면

(4, 8, 10, 14, 16)에 가로수를 더 심어야 한다.

심어져 있는 가로수의 위치가 주어질 때,

모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 구하는 프로그램을 작성하라.

단, 추가되는 나무는 기존의 나무들 사이에만 심을 수 있다.

입력
---
첫째 줄에는 이미 심어져 있는 가로수의 수를 나타내는 하나의 정수 N이 주어진다

(3 ≤ N ≤ 100,000).

둘째 줄부터 N개의 줄에는 각 줄마다 심어져 있는 가로수의 위치가 양의 정수로 주어지며,

가로수의 위치를 나타내는 정수는 1,000,000,000 이하이다.

가로수의 위치를 나타내는 정수는 모두 다르고,

N개의 가로수는 기준점으로부터 떨어진 거리가 가까운 순서대로 주어진다.


출력
---
모든 가로수가 같은 간격이 되도록 새로 심어야 하는 가로수의 최소수를 첫 번째 줄에 출력한다.

예제 입력 1
4
1
3
7
13
예제 출력 1
3
예제 입력 2
4
2
6
12
18
예제 출력 2
5
*/

/**
이번에는 유클리드 호제법이라는 수학적 공식을 사용할 수 밖에 없다.

숫자 2 개의 최대공약수를 구하는 것은 "한 번"의 계산이면 되지만, 이번에는 최대 99,999 번 계산해야 한다. (계산 1 번 == 최대공약수 구하기)

나는 또다시 컴퓨터 CS 를 아우르는 모든 것을 공부하기 위해, 하나의 규칙을 세웠었다.

모르는 것이 있다면, 꼭 이해한 뒤 작성해야 한다.

너무나도 힘들지만, 세밀한 정보가 쌓여 점점 이해해야 할 빈도수가 조금씩이라도 줄어드는 것이 보이고 있다.

따라서, 나는 유클리드 호제법을 나 스스로 이해해보기로 했다.

굳이 왜? 유클리드 호제법을 이해해야 하는가 싶지만,

도대체 어떻게 두 수를 서로 나머지 계산하여 최대공약수를 구하는지 미지수였다.

즉, 이해가 되질 않는다는 것이다.

---

유클리드 호제법 계산 자체는 간단하다.

두 수가 존재 할 때, 나머지가 0 이 될 때 까지 나머지 연산(%) 을 실시한다.

서로 나머지 연산을 번갈아가면서 하는데, 나머지가 0 이 나왔을 때, 해당 나머지 연산을 수행한 수가 바로 "최대 공약수" 가 된다.

이게 어떻게 가능한 것일까? 나는 도저히 이해가 되지 않았다.

그나마 다행인 것은, 유클리드 호제법의 계산 자체는 이미 공개가 되어 있기 때문에,

어떻게 나머지 계산을 통한 결과가 최대 공약수로 이어질 수 있는지 연관관계를 찾아보면 되었다.

어떻게 보면, 이러한 계산을 증명하는 과정이 되는데, 이 과정을 이해하는 것이 내 궁극적 목표인 뛰어난 컴퓨터 엔지니어가 되기 위해서 이를 알아야 한다고 판단했다.

---

이전에 유클리드 호제법의 동작을 메모해 둔 적이 있어, 이를 다시 재사용한다.(예제를.)

&& 예제 1 &&

1071 그리고 1029

마치 소수와도 같아 보이는 이 수들은 일단 소수가 아니다.

* 1071 = 1029 * 1 + 42;
* 1029 = 42 * 24 + 21;
* 42 = 21 * 2 + 0;
* 21 = 0;

즉, 21 이 최대공약수라는 것이다.

---

아니, 어떻게 나머지 연산만으로 최대공약수를 구할 수 있을까?

카페에서 공부하고 나와 집으로 가는 25분동안, 유클리드 호제법의 의미에 대해서 계속 고민했다.

그리고, 나의 짧은 수학적 식견으로 이러한 생각이 유도되었다.


[ 1. 유클리드 호제법은 순서가 상관이 없다. (1029, 1071 순으로 먼저 계산해도 마찬가지라는 것.) ]

예를 들면,

* 1029 = 1071 * 0 + 1029;
* 1071 = 1029 * 1 + 42;
* ....

더 큰 수는 더 작은 수를 그대로 나머지로 남겨버리기 때문에, 순서 자체는 상관이 없다는 것이다.


[ 2. 예를 들어, 1071 과 1029 의 최대공약수는 무엇일까? 생각해보면, 큰 수와 작은 수의 차이보다 더 클 수는 없다는 것을 알게 된다.  ]

위의 의견 또한 걷다가 생각하게 된 것인데,

두 수를 공통적으로 나눌 수 있는 공약수는(자신 포함), 각 수의 차이보다 절대로 클 수 없다라는 것을 발견했다.

더해서, 만약에 1000, 300 이라는 수가 주어질 때, 우리는 최대공약수를 생각해 보자.

이 때, 더 큰 수(1000) 와 작은 수(300) 사이의 최대공약수는 절대로 (큰 수 - 작은 수) 를 뛰어넘을 수 없다.

또한, 더 작은 수 보다 절대적으로 작거나 같은 것이 최대공약수라는 것이다.

그렇다면, 1071 을 1029 로 나머지 연산을 해 버리는것이 "아주 약간" 은 이해가 되는게,

1071 이 1029 의 "몇 천배" 가 된다 한들(당연히 지금은 수가 보이니까),

최대공약수는 무조건 작은 수인 1029 보다 작거나 같아야 한다. 그래야 공통으로 나누는 수를 찾을 수 있기 때문이다.


[ 3. (A = B * xx + 나머지) 라는 식에서, A 는 B 를 나머지 계산을 함으로서, 도출되는 "나머지" 는, A 의 메타데이터가 들어 있을 것이다.  ]

이것 또한 걷다가 생각한 건데, 처음에 나머지 계산을 통해, 서로에게 나올 수 있는 공약수의 최대치를 구한 것은 (어떻게 보면 제한한 것.) 이해가 되었다.

그런데, 서로에게 나머지 연산을 하면서 최대공약수가 구해진다는 것이 도저히 이해가 되지 않았다.

DMT Park 라는 이론수학 유튜버 덕분에 생각난 것인데, 다른 시각으로 보면, 나머지 연산이란,

A, B 가 존재 할 때, A % B 라는 계산은, B 의 몫 따위는 신경쓰지 않고, 정확히 나머지만 남을 때 까지 "빼는 것" 과 동일하다는 생각이 들었다.

즉, A > B 일 때, A - B < B 라는 조건을 만족 할 때 까지, A 에서 B 를 지속적으로 빼는 행위이다.

그리고 남은 수를 사용한다.

그렇다는 것은, 어찌 되었든, A - B 혹은, A % B 의 결과가 A 의 알수없는 연관 메타데이터가 들어 있거나, 혹은 A 와 B 의 상호작용 메타데이터가 들어있다는 이야기로 해석했다.

여기서 내가 말하는 메타데이터란, A 혹은 B 가 담고 있던 "내가 알지 못하는" 수학적 연관관계를 의미한다.

이 연관관계를 "해석" 한다면, 이 나머지 계산 반복을 수행하는 이유를 알 것 같았다.


[ 4. 그렇다면, A % B 는 결국 일종의 A - B 의 확장판과 비슷하다고 생각되는데, 이 과정에서 A 의 정보가 남는가?  ]

이는 A % B --> A 나머지,

B % (A 나머지) 이 과정에서 벌어지는 의문점이다.

처음은 공약수를 담고 있는 수들끼리 계산이 벌어지지만,

그 다음부터는 A 의 나머지와 B 의 나머지가 서로 나머지 계산을 수행하며 최대공약수를 구한다는 것이다.

이게 도대체 어떻게 가능한가 싶다.

------------------------------------------------------

그래서, 한번 1071 와, 1029 의 약수들을 펼쳐보기로 결정했다. 결국, 최대공약수는 서로의 약수들을 참조하기 때문에 연관관계가 있을 것이라고 판단했다.

* 1071 --> 21 * 51 --> (3 * 7) * (3 * 17) --> 1 * 3 * 3 * 7 * 17
* 1029 --> 21 * 49 --> (3 * 7) * (7 * 7) --> 1 * 3 * 7 * 7 * 7

그렇다면, 여기에서 나머지 연산을 통해 도출되는 나머지를 구해보자. 이미 알다시피, 몫은 1이다.

* 1071 - (1029) * 1 = 나머지
* (3 * 3 * 7 * 17) - (3 * 7 * 7 * 7) * 1 = 나머지
* (3 * 7) * (3 * 17 - 7 * 7) * 1 = 나머지
* (3 * 7) * (51 - 49) * 1 = 나머지
* (3 * 7) * (2) * 1 = 42

이 과정을 하다보니 이미 알게 된 게, 각 공약수를 서로 비교하여 중첩되는 것만 골라 곱하면 그대로 최대공약수가 된 다는 특징을 다시금 알게 되었다..

* 1029 - (42) * (24 --> 컴퓨터 계산 몫) = 나머지
* (3 * 7 * 7 * 7) - (2 * 3 * 7) * (2 * 2 * 2 * 3) = 나머지
* (3 * 7 * 7 * 7) - (2 * 2 * 2 * 2 * 3 * 3 * 7) = 나머지
* (3 * 7) * (7 * 7 - 2 * 2 * 2 * 2 * 3) = 나머지
* (3 * 7) * (49 - 48) = 나머지
* (3 * 7) * (1) * 1 = 21

무언가 결과론적으로 최대공약수인 3 * 7 이 무언가 지속적으로 띄는 양상. 하지만, 아직은 추측일 뿐이다.

아직 과정이 완료되지 않았다.

* 42 - (21) * (2 --> 컴퓨터 계산 몫) = 나머지 --> 이미 0 인 것을 알고 있으나, 일단 진행.
* (2 * 3 * 7) - (3 * 7) * (2) = 나머지
* (3 * 7) * (2 - 2) = 나머지
* (3 * 7) * (0) = 0

즉, 3 * 7 이 정답이다.

최대공약수는 각 수를 구성할 수 있는 최소의 값들로 펼쳐놓고,

합집합에 해당되는 수들을 곱하여 최대공약수를 구할 수 있다.

이미 우리는 1071 과 1029 라는 수를 펼쳐놓으면서, 합집합이 {1, 3, 7} 임을 알고 있었다.

이 수들을 곱하는 21이 바로 나오지만, 우리는 유클리드 호제법을 통해 최대 공약수를 구할 수도 있었다.

그렇다는 것은,

유클리드 호제법은 나머지 계산 당하는 A, 그리고 나머지 계산을 수행하는 B 가

지속적으로 최대 공약수에 해당하는 구성 성분을 교차적으로 가지고 있다는 의미라고 생각한다. (반쯤 확신)

----

그렇다면, 이를 검증하기 위해 또 다른 예시를 사용하기로 했다.

바로, A : 78696, B : 19332

이번에도 겹치는 곱이 존재하여 이를 변형하게 된다면, 앞에 붙는 수가 결국 최대공약수이며,

나머지 계산이 0 이 될 때 까지, 이를 보전하여 결과물로서 최대 공약수를 뽑아낸다는 결론에 도달할 수 있을 것이다.

조금 큰 수라서 길게 뽑아질 것 같긴 한데, 그래도 검증을 위해서 시도하자.

A : 2 * (39348) --> 2 * 2 * (19674) --> 2 * 2 * 2 * (9837) --> 2 * 2 * 2 * 3 * (3279) --> 2 * 2 * 2 * 3 * 3 * (1093) --> 1093 약수가 도저히 계산이 안되서 약수 판별기에 넣음 (소수임)
A : 1 * 2 * 2 * 2 * 3 * 3 * 1093

B : 2 * (9666) --> 2 * 2 * (4833) --> 2 * 2 * 3 * (1611) --> 2 * 2 * 3 * 3 * (537) --> 2 * 2 * 3 * 3 * 3 * (179) --> 179 < 16 * 16 이므로, 16 내에서 나눠보면 179 는 소수란 걸 알게됨.
B : 1 * 2 * 2 * 3 * 3 * 3 * 179

---

자, 이제 유클리드 호제법은 A, B 양쪽이 서로 번갈아 가며 나머지 계산을 했을 때, 최대 공약수가 무조건 남는다는 원리를 이용하여 계산한다는 것을 검증해 볼 차례인 것 같다.

큰 수인 A(78696), B(19332) 순으로 시작한다.

* 78696 - (19332) * (4 --> 컴퓨터 계산) = 나머지
* (1 * 2 * 2 * 2 * 3 * 3 * 1093) - (1 * 2 * 2 * 3 * 3 * 3 * 179) * (2 * 2) = 나머지
* (1 * 2 * 2 * 3 * 3) * (2 * 1093 - (3 * 179) * 4) = 나머지
* (1 * 2 * 2 * 3 * 3) * (2186 - 2148) = 나머지
* (1 * 2 * 2 * 3 * 3) * (38) = 나머지 --> 36 * 38 == 1368

몫은 따로 분리하여 최종 나머지를 계산하는 데에 사용했으며,

순수 A 와 B 사이 구성 수 합집합만을 떼어서 계산했다. --> 이게 맞다.

* 19332 - (1368) * (14 --> 컴퓨터 계산) = 나머지
* (1 * 2 * 2 * 3 * 3 * 3 * 179) - (1 * 2 * 2 * 2 * 3 * 3 * 19) * 14 = 나머지
* (1 * 2 * 2 * 3 * 3) * (3 * 179 - 2 * 19 * 14) = 나머지
* (1 * 2 * 2 * 3 * 3) * (537 - 532) = 나머지
* (1 * 2 * 2 * 3 * 3) * (5) = 180

역시, 이 유클리드 호제법은 최대 공약수의 흔적은 "그대로" 유지 한 채, 나머지는 0 이 나올 때 까지 계산하는 논리라고 거의 확신한다.

* 1368 - (180) * 7 = 나머지
* (1 * 2 * 2 * 2 * 3 * 3 * 19) - (1 * 2 * 2 * 3 * 3 * 5) * (7) = 나머지
* (1 * 2 * 2 * 3 * 3) * (2 * 19 - 5 * 7) = 나머지
* (1 * 2 * 2 * 3 * 3) * (3) = 나머지 --> 108

그 다음 단계도 가 보자.

* 180 - (108) * 1 = 나머지
* (1 * 2 * 2 * 3 * 3 * 5) - (1 * 2 * 2 * 3 * 3 * 3) * 1 = 나머지
* (1 * 2 * 2 * 3 * 3) * (5 - 3) = 나머지 --> 72

얼마 남지 않았다.

* 108 - (72) * 1 = 나머지
* (1 * 2 * 2 * 3 * 3 * 3) - (1 * 2 * 2 * 2 * 3 * 3) * 1 = 나머지
* (1 * 2 * 2 * 3 * 3) * (3 - 2) = 36

이제 마지막이다.

* 72 - (36) * 2 = 나머지
* (1 * 2 * 2 * 2 * 3 * 3) - (1 * 2 * 2 * 3 * 3) * 2 = 나머지
* (1 * 2 * 2 * 3 * 3) * (2 - 2) = 나머지
* (1 * 2 * 2 * 3 * 3) * (0) = 나머지 == 0 !!

----

우리는 2 가지 상황을 예시로 들었다.

1. 1071 과 1029 의 최대공약수
2. 78696 과 19332 의 최대공약수.

이 두 상황의 공통점이 무엇인지 확실히 알게 되었다.

바로, 구성 수들로 펼쳐놓고, 공통 수를 치환하여 "(앞 부분) * (뒷 부분) = 나머지" 형태를 띌 때,

항상 "앞 부분" 은 항상 최대공약수를 의미한다는 것이다.

따라서, 이것이 의미하는 바가 무엇일까?

유클리드 호제법에서 양 수는 서로를 번갈아 나머지 계산을 수행하게 된다.

그러나, 언제나 항상(처음부터 끝까지) "앞 부분" 에는 최대공약수가 자리잡고, 뒷 부분은 이어질 나머지 계산을 위한 나머지를 계산하는 것이다.

----

즉, A % B 라는 나머지 계산을 수행 할 때, 계산된 나머지는 A 와 B 의 최대 공약수가 될 구성 성분을 가지고 있다는 점이다.

굉장히 추상적이고 약간은 틀린 비유를 하자면, A 와 B 의 최대공약수를 구하는 루프는, 어떻게 보면 필요 없는 구성 성분을 없애가는 과정에 비유할 수 있을 것 같다.

이 하나의 과정은 수학적으로 표현되지 않고, 개발자인 우리는 단순히 외우거나, 혹은 기호인 % 나머지 계산 이라는 의미에 묻혀 이런 중요한 수학 과정을 넘겼을 지도 모른다.

---

&& 마무리 &&

유클리드 호제법은 은 주어진 두 수에 대한 최대 공약수를 굉장히 빠른 속도로 구할 수 있는 방식이다.

특히, 유클리드 호제법은 컴퓨터로 표현 시, 이에 대한 묘사가 세밀하지 않고, 단순히 "%" 로 계산되기 때문에 내부의 의미를 이해하기 어려운 것이 당연하다 생각된다.

그래도 유클리드 호제법을 이해하기 위해서, 나는 외부의 도움 없이, 내 머릿속의 생각과 추론을 통해 유클리드 호제법을 이해했다는 데 의미를 둔다.

당연히 수학적으로도 이것이 표현되어 있겠지만, 나는 좀 더 컴퓨팅 사고 방향적으로 이해했다고 생각한다.

이제 나는, "유클리드 호제법을 사용할 줄 알아요" 가 아닌, "유클리드 호제법의 사용 의미와 내부 과정을 이해했어요" 급으로 공부했다고 말할 수 있을 것 같다.

---

&& 그렇다면, 그냥 두 수의 구성 성분을 집합으로 구해서, 교집합을 그대로 곱해 버리면 되는 것 아닌가? &&

이것도 두 수의 최대공약수를 구하는 방식 중 하나다. 그럼에도 불구하고, 왜 유클리드 호제법을 사용할까??

이는 하나의 예시를 생각 해 보면 된다.

만약에, 10만 쯤 되는 소수와, 100만쯤 되는 소수가 어쩌다 주어졌다고 생각 해 보자. 우리는 이 두 수가 소수인지 모른다.

그러나, 우리는 이 두 수의 최대 공약수를 구해야 한다면, "일반적인 방식으로(유클리드 제외하고)" 빠르게 구할 수 있을까?

더군다나 지금 문제에서는 주어지는 각각의 수가 최대 100,000 이므로, 그 차이점을 최대 99,999 번을 계산해야 한다.

정말로, 99,999 번, 매우 큰 수들을 그것도 매우 많이, 루프문만을 돌려서 최적화 할 수 있을까?

이것은 유클리드 호제법을 통하여, 매우 큰 서로의 수의 최대공약수를 약 최대 7 번의 계산 만에 알아낼 수 있는 방법은 유클리드 호제법이라는 것이다.

따라서, 유클리드 호제법을 통하여 이 문제를 해결해야 한다. (아무리 빠른 C 라지만, 단순 계산만으로는 해결 할 수 없다.)

--------------

&& 다시 돌아와서, 유클리드 호제법의 풀이가 얼마나 가치 있는지 돌아보자 (중요!!!!!!!!!!!) &&

나머지 연산을 통해 최대공약수를 구한다는 과정은 그 내부를 상상하기가 어렵다.

하지만, 나는 최대공약수가 두 수의 구성 성분 (EX - 2 * 2 * 3...) 의 교집합이라는 것을 이용하여,

2 가지 예제를 들어 유클리드 호제법이 어떻게 작동하는지 알아봤다.

다행히도 내 추측이 맞아서 다행이라는 생각이 든다..

즉, 유클리드 호제법은, 두 수를 나눌 수 있는 가장 작은 구성 성분들로 나열했을 때,

최대공약수로 묶을 수 있고, 공유되지 않는 나머지 성분들의 차이의 계산으로 나머지를 구한다.

EX - (1 * 2 * 2 * 3) * (3 * 5 - 2 * 3) --> 이러한 구성 구성을 띄게 된다.

여기서 1 * 2 * 2 * 3 은, 최대공약수이다.

당연히 수학적으로 구성 성분을 나열했을 때, 공유 구성성분을 구하여 곧바로 최대공약수를 구할 수 있겠지만,

문제는 컴퓨터는 그것을 모른다는 것이다. 컴퓨터는 단순히 "수" 만 알아듣는다.

따라서, 나머지 연산을 했을 때, 나오는 결과는 최대공약수에 해당하는 수의 곱으로 이루어져 있다. (무조건)

이를 이용하여, EX - (1 * 2 * 2 * 3) * (2 - 2) == 0 과 같이, 정확히 나누어질 때, 최대공약수를 구할 수 있는 것이다.

이를 양 수를 번갈아 나머지 계산을 한다면, 두 수의 최대공약수가 나오게 된다.

*/

#include<stdio.h>

extern void* malloc(size_t byte);
extern void free(void* memory);

int euclidean_algorithm(int n1, int n2);

char* intToStr(int target);
int parseInt(const char* str);
_Bool isBlank(char ch);

int main(void) {
    char input[255];

    fgets(input, sizeof(input), stdin);

    int N = parseInt(input);

    int* list = (int*)malloc(sizeof(int) * (N + 1));

    fgets(input, sizeof(input), stdin);

    *list = parseInt(input);

    int max_divisor = -1;

    int idx = 1;
    while(idx < N) {
        fgets(input, sizeof(input), stdin);

        int currNum = parseInt(input);

        *(list + idx) = currNum;

        int diff = *(list + idx) - *(list + idx - 1);

        if(max_divisor == -1) {
            max_divisor = diff;
        } else {
            max_divisor = euclidean_algorithm(max_divisor, diff);
        }

        idx++;
    }

    int newTreeTotal = 0;
    int prevLen = *(list);
    idx = 1;
    while(idx < N) {
        int currLen = *(list + idx);

        int diff = currLen - prevLen;

        newTreeTotal += (diff / max_divisor) - 1;

        prevLen = currLen;

        idx++;
    }

    char* result = intToStr(newTreeTotal);
    fputs(result, stdout); fputc('\n', stdout);
    free(result);

    return 0;
}

int euclidean_algorithm(int n1, int n2) {
    int r = -1;
    while(n1 % n2 != 0) {
        r = n1 % n2;

        n1 = n2;
        n2 = r;
    }

    return n2;
}

char* intToStr(int target) {
    int sign = 1;
    int len = 0;

    if(target < 0) {
        target *= -1;
        sign = -1;
    }

    int temp = target;
    do {
        temp /= 10;
        len++;
    } while(temp != 0);

    int size = sign == 1 ? len : len + 1;
    int endIdx = size - 1;
    int startIdx = sign == 1 ? 0 : 1;

    char* result = (char*)malloc(sizeof(char) * (size + 1));
    *(result + size) = 0;

    int idx = endIdx;
    while(idx >= startIdx) {
        *(result + idx--) = (target % 10) + '0';
        target /= 10;
    }
    if(sign == -1) {
        *result = '-';
    }

    return result;
}
int parseInt(const char* str) {
    int sign = 1;
    int result = 0;

    char* strPtr = (char*)str;
    if(*strPtr == '-') {
        sign = -1;
        strPtr++;
    }

    while(isBlank(*strPtr) != 1) {
        result *= 10;
        result += *strPtr++ - '0';
    }

    return result * sign;
}
_Bool isBlank(char ch) {
    if(ch == 32 || ch == 0) {
        return 1;
    } else if(ch >= 9 && ch <= 13) {
        return 1;
    } else {
        return 0;
    }
}
