/**
    @Author : 공담형
    @Email : rhdwhdals8765@gmail.com
    @Github : https://github.com/damhyeong
    @Blog : https://codecreature.tistory.com

    "최소한의" 기능과 라이브러리를 사용하고, 나머지 기능을 직접 구현하기 때문에,

    다른 C 코드를 참조하시는 것이 좋습니다.

    블로그에서 다양한 컴퓨터 관점과 Computer Science 를 다루고 있으니 궁금하면 들러보셔요!

    참고로, AI 작성 글이 아니라, 진짜 공식문서 뒤져가면서 힘들게 얻은 지식을 나눠보려고 합니다.
*/
/**
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	512 MB	32801	16048	15077	49.823%

문제
---
오늘도 서준이는 알고리즘의 수행시간 수업 조교를 하고 있다.

아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

입력의 크기 n 이 주어지면 MenOfPassion 알고리즘 수행 시간을 예제 출력과 같은 방식으로 출력해보자.

MenOfPassion 알고리즘은 다음과 같다.
---------------------------------------------------------------------------
MenOfPassion(A[], n) {
    sum <- 0;
    for i <- 1 to n - 2
        for j <- i + 1 to n - 1
            for k <- j + 1 to n
                sum <- sum + A[i] × A[j] × A[k]; # 코드1
    return sum;
}
---------------------------------------------------------------------------

입력
---
첫째 줄에 입력의 크기 n(1 ≤ n ≤ 500,000)이 주어진다.

출력
---
첫째 줄에 코드1 의 수행 횟수를 출력한다.

둘째 줄에 코드1의 수행 횟수를 다항식으로 나타내었을 때, 최고차항의 차수를 출력한다.

단, 다항식으로 나타낼 수 없거나 최고차항의 차수가 3보다 크면 4를 출력한다.

예제 입력 1
7
예제 출력 1
35
3
코드1 이 35회 수행되고 알고리즘의 수행 시간이 n^3에 비례한다.
*/
/**
 * if n == 7
 *  i = 1;
 *  j = 2;
 *  k = 3;
 *  first kLoop = 3, 4, 5, 6, 7 == 5;
 *
 *  n - k = 4;
 *  따라서, n - k 로 하나의 루프를 정의하면 안된다.
 *  계산 후, + 1 을 해 주어야 한다.
 *  나머지 i, j 루프는 내부에서 정상적으로 돌아가도록 되어있기 때문이다.
 *
 * ---
 * 시간 초과 에러가 떴다. 어떠한 수학 식을 추가해 주어야 하는듯.
 *
 * k 뿐만 아니라, j 까지 포함하여 계산하면 바로 해결이 되긴 한다.
 *
 * j 내부에서 k 가 루프를 돌고,
 * i < j < k 는 무조건 성립한다.
 *
 * 만약에 i 가 1 이며, j 가 2 이며, n 이 5 라면,
 *
 * j = 2
 * - k : 3
 * - k : 4
 * - k : 5
 *
 * j = 3
 * - k : 4
 * - k : 5
 *
 * j = 4 (끝)
 * - k : 5
 *
 * 즉, i 가 1, j 가 2 시작이라면, 내부 루프는 3 + 2 + 1 이다.
 *
 * 그렇다면, i 가 1 일 때, j, k 두 변수로 인한 루프의 결과는, 3 + 2 + 1 == 6 이다.
 * i 가 2 일 때, j, k 두 수로 인한 루프의 결과는, 2 + 1 == 3 이다.
 * i 가 3 일 때, j, k 두 수로 인한 루프의 결과는, 1 == 1 이다.
 *
 * n 이 5 일 때, 시간 복잡도로 인한 총 계산 수는 10 이다.
 *
 * ---------------------------
 * 조금 난이도를 올려서, n 이 7 일 떄를 가정한다.
 *
 * i = 1
 *  j = 2
 *    k = 3
 *    k = 4
 *    k = 5
 *    k = 6
 *    k = 7
 *  j = 3
 *    k = 4
 *    k = 5
 *    k = 6
 *    k = 7
 *  j = 4
 *    k = 5
 *    k = 6
 *    k = 7
 *  j = 5
 *    k = 6
 *    k = 7
 *  j = 6
 *    k = 7
 *
 * i = 2
 *   j = 3 부터 시작.
 *
 * 즉, i == 1 일 때, 5 + 4 + 3 + 2 + 1 = 15
 * 그렇다면, i == 2 일 때, j 는 3 부터 시작하므로, 4 + 3 + 2 + 1 = 10
 * i == 3 일 때, 3 + 2 + 1 = 6
 * i == 4 일 때, 2 + 1 = 3
 * i == 5 일 때, 1 = 1
 *
 * 즉, n 이 7 일 때, 15 + 10 + 6 + 3 + 1 == 35 이다.
 *
 * -----------------
 *
 * 위의 2 가지 예시에서 내가 특정한 수학 식을 도출할 수 있을 것 같다.
 *
 * 먼저, n == 5 였을 때를 가정하여 n 으로 변형 해 보겠다.
 *
 * i 가 1 일 때, j, k 두 변수로 인한 루프의 결과는, 3 + 2 + 1 == 6 이다.
 * i 가 2 일 때, j, k 두 수로 인한 루프의 결과는, 2 + 1 == 3 이다.
 * i 가 3 일 때, j, k 두 수로 인한 루프의 결과는, 1 == 1 이다.
 *
 * (n - 2) + (n - 3) + (n - 4) == 6
 * (n - 3) + (n - 4) = 3
 * (n - 4) = 1;
 *
 * 즉, n == 5 일 때, (n - 2) + 2(n - 3) + 3(n - 4) = y 이다. y == 10;
 * 혹은, n == 5 일 때, (6 * n) - (20) = y;
 * 흠... 아직 무언가가 잡히는 수식이 없다. 이것이 i -> n - 2, j -> n - 1, k -> n (i < j < k) 를 만족하는 수식이라고 볼 수 없다.
 *
 * ----------------
 *
 * 이제 n == 7 일 때를 가정한다.
 *
 * i == 1 일 때, 5 + 4 + 3 + 2 + 1 = 15
 * i == 2 일 때, 4 + 3 + 2 + 1 = 10
 * i == 3 일 때, 3 + 2 + 1 = 6
 * i == 4 일 때, 2 + 1 = 3
 * i == 5 일 때, 1 = 1
 *
 * i == 1 ==> (n - 2) + (n - 3) + (n - 4) + (n - 5) + (n - 6) = 15
 * i == 2 ==> (n - 3) + (n - 4) + (n - 5) + (n - 6) = 10
 * i == 3 ==> (n - 4) + (n - 5) + (n - 6) = 6
 * i == 4 ==> (n - 5) + (n - 6) = 3
 * i == 5 ==> (n - 6) = 1
 *
 * 즉, n == 7 일 때, (n - 2) + 2(n - 3) + 3(n - 4) + 4(n - 5) + 5(n - 6) = y 이다. y == 35
 * 간단하게 수를 모았을 떄, (5 + 4 + 3 + 2 + 1)(n) - (2 + 6 + 12 + 20 + 30) = y ==> (15 * n) - (70) = y
 *
 * --------------------
 *
 * 다시 간략화 하여,
 *
 * n == 5 일 때,
 * n == 5 일 때, (n - 2) + 2(n - 3) + 3(n - 4) = y 이다. y == 10;
 * n == 5 일 때, (6 * n) - (20) = y;
 *
 * n == 7 일 때, (n - 2) + 2(n - 3) + 3(n - 4) + 4(n - 5) + 5(n - 6) = y 이다. y == 35
 * n == 7 일 때, (15 * n) - (70) = y
 *
 * n 만이 변인요소이고, 나머지 수와 y 자체는 같은 규칙을 가진 수식을 가진다고 가정한다.
 *
 * 여태까지의 과정으로, n 앞에 붙은 수는 어떤 수로 이루어져 있는지 짐작 할 수 있다.
 *
 * 바로, i 가 반복되며 줄을 때 마다, 더해진 수이다.
 *
 * 즉, i = 5 라면, 모든 루프에서 더해지는 n 의 개수들은 6 개이다.
 *    i = 7 이라면, 모든 루프에서 나타난(더해지는) n 의 개수들은 15 개이다.
 *
 * 위에서 나는 수식을 펼쳤다. 그 과정에서, n 의 수식은 2차원 평면처럼 펼쳐졌다.
 *
 * n 이 더 클 수록, n 앞에 곱해지는 수는 더 커질 것이다.
 *
 * n - ?, n - ?, n - ?, ...
 * n - ?, n - ?, ...
 * n - ?, ...
 *
 * 그런데, 이렇게 펼쳐진 2 차원 단순 수식은 "도형으로서" 의 계산을 가능하게 해 준다.
 *
 * 만약에, n 이 6이라면, 이러한 현상이 펼쳐진다.
 *
 * n - ?, n - ?, n - ?, n - ? = ?
 * n - ?, n - ?, n - ? = ?
 * n - ?, n - ? = ?
 * n - ? = ?
 *
 * 더 간단하게,
 *
 * O, O, O, O
 * O, O, O
 * O, O
 * O
 *
 * 이렇게 표현 할 수 있을 것이다.
 *
 * 이를 삼각형으로서 계산하지 않을 것이다.
 *
 * 잘 생각해 보자.
 *
 * 아래 부분을 위에 180도 돌려서 결합시키면, 직사각형 모양이 완성된다.
 *
 * 즉, n 이 5 라면,
 *
 * O, O, O
 * O, O
 * O
 *
 * 이었으며,
 *
 * 이를 x 축이던, y 축이던 반으로 자른다.
 *
 * 그리고, 이를 원하는 방향으로 붙여보자.
 *
 * 그렇다면 결과는, (n == 5)
 *
 * O, O, O
 * O, O, O
 *
 * 즉, n 이 5 일 경우, n 의 개수는 6 개가 나온다. (2 * 3)
 *
 * n == 6 의 경우,
 *
 * O, O, O, O
 * O, O, O
 * O, O
 * O
 *
 * 이며,
 *
 * O, O, O, O, O
 * O, O, O, O, O
 *
 * 즉, n 은 6 일 경우, n 개수는 10 개가 나온다. (2 * 5)
 *
 * n == 7 의 경우,
 *
 * O, O, O, O, O
 * O, O, O, O
 * O, O, O
 * O, O
 * O
 *
 * 이며, 이는
 *
 * O, O, O, O, O
 * O, O, O, O, O
 * O, O, O, O, O
 *
 * 의 직사각형이 이루어진다. n 의 개수는 15 개가 나온다. (3 * 5)
 *
 *
 * 결국 어떠한 축이던 길이가 다른 같은 삼각형이 존재한다. (각 변의 길이가 달라 직사각형이 되기 때문.)
 * 그리고, 이 삼각형은 특정 축에서 반으로 잘라 다시 붙이니 직사각형이 되었다.
 *
 * 그렇다는 것은, 각 원소로 인해 같은 변의 길이를 가져 보이는 삼각형이, 특정 부분에 + 1 한 상태로 " / 2" 한다면,
 *
 * 그것이 바로 n 의 개수가 된다는 것이다.
 *
 * n == 5, ==> (n - 2) * (n - 1) / 2 == 6
 * n == 6, ==> (n - 2) * (n - 1) / 2 == 10
 * n == 7, ==> (n - 2) * (n - 1) / 2 == 15
 *
 *
 * 위의 규칙을 보건대, 우리는 이러한 수식으로 변형시킬 수 있다.
 * n 은 5 일 때, (4 * 3 / 2) * (n) - 20 = y;
 * n 은 6 일 때, (5 * 4 / 2) * (n) - ? = y;
 * n = 7 일 때, (6 * 5 / 2) * (n) - 70 = y;
 *
 * n == 5 ==> (n - 1) * (n - 2) * n / 2 - 20 ==> (n)(n - 1)(n - 2) / 2 - 20 = y;
 * n == 7 ==> (n - 1) * (n - 2) * n / 2 - 70 ==> (n)(n - 1)(n - 2) / 2 - 70 = y;
 *
 * 그런데, 이 과정에서 동일한 규칙을 찾을 수 있다.
 *
 * 바로, 마지막 '-20' 과, '-70' 이다.
 *
 * 이는 각각 n = 5 일 때, 10 이며, n = 7 일 때, 35 이다.
 *
 * 그렇다면, 이 식은 이렇게 풀어 볼 수 있다.
 *
 * n ==> n(n - 1)(n - 2) / 2 -2y = y;
 *
 * n --> n(n - 1)(n - 2) / 2 = 3y; --> n(n - 1)(n - 2) / 2 * 3 = y;
 *
 * 드디어, 식이 도출되었다.
 *
 * 이를 사용하여 문제를 푼다.
 */

#include<stdio.h>

extern void* malloc(size_t byte);
extern void free(void* memory);

char* longToStr(long long target);
long parseLong(const char* str);
_Bool isBlank(char ch);

int main(void) {
    char input[100];

    long n = parseLong(fgets(input, sizeof(input), stdin));

/**
 * n ==> n(n - 1)(n - 2) / 2 -2y = y;
 *
 * n --> n(n - 1)(n - 2) / 2 = 3y; --> n(n - 1)(n - 2) / 2 * 3 = y;
 */


    long total = n * (n - 1) * (n - 2) / (2 * 3);

    char* result = longToStr(total);

    fputs(result, stdout); fputc('\n', stdout);
    fputs("3\n", stdout);

    free(result);

    return 0;
}


char* longToStr(long long target) {
    int sign = 1;
    int len = 0;

    if(target < 0) {
        target *= -1;
        sign = -1;
    }

    long temp = target;
    do {
        temp /= 10;
        len++;
    } while(temp != 0);

    int size = sign == 1 ? len : len + 1;
    int endIdx = size - 1;
    int startIdx = sign == 1 ? 0 : 1;

    char* result = (char*)malloc(sizeof(char) * (size + 1));
    *(result + size) = 0;

    int idx = endIdx;
    while(idx >= startIdx) {
        *(result + idx--) = (target % 10) + '0';
        target /= 10;
    }
    if(sign == -1) {
        *result = '-';
    }

    return result;
}
long parseLong(const char* str) {
    long sign = 1;
    long result = 0;

    char* strPtr = (char*)str;
    if(*strPtr == '-') {
        sign = -1;
        strPtr++;
    }

    while(isBlank(*strPtr) != 1) {
        result *= 10;
        result += *strPtr++ - '0';
    }

    return result * sign;
}
_Bool isBlank(char ch) {
    if(ch == 32 || ch == 0) {
        return 1;
    } else if(ch >= 9 && ch <= 13) {
        return 1;
    } else {
        return 0;
    }
}
