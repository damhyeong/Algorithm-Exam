/**
    @Author : 공담형
    @Email : rhdwhdals8765@gmail.com
    @Github : https://github.com/damhyeong
    @Blog : https://codecreature.tistory.com

    "코드를 보다가 궁금하시면 EMAIL 로 연락 주셔도 괜찮습니다!"

    "최소한의" 기능과 라이브러리를 사용하고, 나머지 기능을 직접 구현하기 때문에,

    다른 C 코드를 참조하시는 것이 좋습니다.


    블로그에서 다양한 컴퓨터 관점과 Computer Science 를 다루고 있으니 궁금하면 들러보셔요!

    참고로, AI 작성 글이 아니라, 진짜 공식문서 뒤져가면서 힘들게 얻은 지식을 나눠보려고 합니다.
*/

/**
전깃줄

시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
1 초	128 MB	47573	23339	18685	48.636%

문제
---
두 전봇대 A와 B 사이에 하나 둘씩 전깃줄을 추가하다 보니 전깃줄이 서로 교차하는 경우가 발생하였다.

합선의 위험이 있어 이들 중 몇 개의 전깃줄을 없애 전깃줄이 교차하지 않도록 만들려고 한다.

예를 들어,

< 그림 1 >과 같이 전깃줄이 연결되어 있는 경우

A의 1번 위치와 B의 8번 위치를 잇는 전깃줄,
A의 3번 위치와 B의 9번 위치를 잇는 전깃줄,
A의 4번 위치와 B의 1번 위치를 잇는 전깃줄을 없애면

남아있는 모든 전깃줄이 서로 교차하지 않게 된다.

< 그림 1 >

전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다.

전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때,

남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.


입력
---
첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다.

전깃줄의 개수는 100 이하의 자연수이다.

둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다.

위치의 번호는 500 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.


출력
---
첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.

예제 입력 1
8
1 8
3 9
2 2
4 1
6 4
10 10
9 7
7 6
예제 출력 1
3
*/

/**
혹시 이 코드 주석을 보고 있으며, 그림이 궁금하다면,

https://www.acmicpc.net/problem/2565

이 사이트에 방문하시길 바랍니다.

---

문제 인식 :

만약에, 정확하게 "어떤 전선들" 이 결국에 연결되었는가를 구하게 된다면,

여러 정답이 나올 수 있으며, 이 과정은 dfs(재귀) 방식으로 풀어가야 할 것이다.

문제는, 전선 1 개를 없애는 모든 과정을 출력하는 것도, 전선 2 개를 없애는 모든 과정을 출력하는 것도 아니다.

"몇 개의 전선" 을 삭제해야 하는지 모르는 상태 인 것이다.

따라서, 재귀와 메서드 깊이를 통한 풀이는 비정상적인 계산양을 가지게 될 것이다.

(전선 개수 1 개부터, N - 1 개 까지를 삭제한다고 가정한다면, 하나의 반복 과정에서 재귀를 실행하는 수준. --> N - 1 번 재귀 메서드가 시작된다 ㅋㅋㅋㅋㅋ)

연결된 전선의 개수와 정보를 통하여, 이를 최소 값으로 누적해 구해야 한다.

---

그런데, 문제는 어떤 상황에서 전선을 "삭제" 해야하는지 정확한 기준을 정해야 한다는 것이다.

정확히, (x1, y1), (x2, y2) 상황에서, x1 < x2 일 때, y1 > y2 이면 안된다는 것이다.

위의 상태를 교차 상태라고 말할 수 있다.

---

그런데, 여기서 궁금한 점이 생긴다.

문제 설명에서는 마치

* 1 8
* 3 9
* 4 1

이 전깃줄만 없애면 최소로 자를 수 있다고 이야기한다.

그러나, 다른 방식을 찾아보면,

* 1 8
* 2 2
* 3 9

이 전깃줄을 없애도 교차 지점이 사라진다.

즉, 특정 조건을 충족하는 전기줄을 저장하면 되겠는데,

이게 "삭제" 될 전깃줄을 저장할 것인지,

"저장" 될 전깃줄을 보관할 것인지 선택해야 하는 것 같다.

---

솔직히 말하자면, 문제 클릭 전 대표적인 설명으로 적혀있는 문구, "LIS - 2" 라는 것을 보고, 내가 이전에 풀었던 방식을 회고하며 규칙을 생성했다.

LIS 란, 특정 규칙을 준수하는 가장 긴 수열의 길이를 구한다. 이것이 오름차순이 될 수도 있고, 내림차순이 될 수도 있다.

혹은, 문제에서 제시하는 특정 규칙을 따라 구할 수도 있는 것이다.

---

LIS 의 풀이 방식은 굉장히 독특했는데, 여러 방식 중, 하나의 "단위 배열" 을 만들어서,

만들어 질 수 있는 "모든 부분 수열" 을 하나의 배열에 저장한다는 것이 놀라웠다.

즉, 모든 부분 수열이 "최대 길이" 가 될 수도 있게끔 알고리즘이 형성 되어 있다.

간단한 예시로, [10 20 30 40 50 1 2 3 4 5 6 7] 이 있다.

여기서 가장 긴 수열은 무엇인가? 당연히 1 ... 7 일 것이다.

그렇다면, 기존의 가장 긴 배열, (10, 20, 30, 40, 50) 이 존재하고 있을 때,

"1" 을 맞닥들인 상황에서, 내부의 10 은 "1" 로 교체가 된다.

"2" 를 맞닥들인다면, "20" 은 "2" 로 교체가 된다.

...

결국 (1, 2, 3, 4, 5, 6, 7) 이 될 것이다.

그러나, 다른 예시로 [10 20 30 40 50 1 2 3] 이 있다.

이 예시의 가장 긴 증가 부분 수열은, (10, 20, 30, 40, 50) 일 것이다.

그러나, LIS 계산 과정의 마무리에서 내부 값을 확인한다면,

(1, 2, 3, 40, 50) 이다. --> 길이 5

내부의 부분 수열을 저장했지만, 이 수열은 입력에서 나올 수 있는 실제 최대 길이의 증가 수열이 "절대로" 아니다.

---

그렇다면, 왜 LIS 는 이러한 방식으로 계산이 되는 것일까?

가장 긴 증가 부분 수열을 구하라고 할 때,

간단한 예제에서는 한눈에 어떤 수열이 최대 길이인지는 알 수 있으나,

길이가 1000 이상이 되면 인간으로서는 솔직히 힘들다.

앞에서 저장된 최대 길이의 수열은, 상대적으로 뒷 부분에 나오는 수열에 비해 작을 가능성이 당연히 존재한다.

따라서, 현재 마지막으로 저장된 "50" 과 같은 수 보다 작을 때, 이 수는 들어갈 수 있는 가장 작은 포지션으로 들어간다.

---

단순 수열로서의 최대 길이 증가, 감소 수열을 구한다는 특징을 여기에 부여해 보기로 했다.

최대 증가 수열은, 단순 2 개의 요소를 비교했을 때, "x 번째 < x + 1 번째가 더 크다" 로 이해 할 수 있다.

그렇다면, 교차를 따져보자.

위에서 내가 제시한 가장 중요한 규칙이 있는데, (x1, y1), (x2, y2) && (x1 < x2) 일 때, (y1 < y2) 가 성립되어야 한다.

즉, 우리의 증가 규칙은 "위의 규칙" 으로 치환 될 수 있다.

---

문제에서는 "없애야 하는 전깃줄의 최소 개수 를 구하라" 고 말했다.

물론, 이 방식으로도 구할 수 있는 방식이 있겠지만,

나는 역으로 성립될 수 있는 전깃줄의 최대 개수를 구하면 된다는 아이디어가 떠올랐다.

(x1, y1), (x2, y2) && (x1 < x2) 일 때, (y1 < y2) 를 성립하는 최대 전깃줄은, "서로 교차되지 않는 전깃줄의 최대 개수"를 의미한다.

---

그렇다는 것은, 위의 규칙이 성립하지 않는다면, 상대적으로 인덱스가 작은 장소에 들어가야 한다는 결론이 나온다.

그리고 각 번호는 개별되는 단 하나의 전깃줄에 연결되므로, "같다" 는 없다. 작고, 큼 이 2 가지 속성만 비교하면 된다.

---

먼저 수십 줄 정도 풀이를 작성하고 나서 깨닫은 건데,

입력을 "먼저" 받고 난 후, 정렬 후 진행해야 한다.

입력을 정렬 한 이후, list 에 이러한 내용으로 간단한 2 차원 배열이 형성되었다고 가정한다. (정렬은 각자 알아서)

정렬 이후 List :
[1, 8]
[2, 2]
[3, 9]
[4, 1]
[6, 4]
[7, 6]
[9, 7]
[10, 10]

---

이제, 이들을 맨 위에서부터 차례로 순회하며 LIS 알고리즘을 적용 해 보자.

제일 중요한 것은, (x1 < x2) && (y1 < y2) 라면, x1 --> x2 가 성립되며,

이 조건이 성립하지 않는다면, 누적 동적 리스트 내부에 새로이 값을 매김하게 된다.

---

####

초기화

유동적 리스트 : { [0, 0] }

####

현재 : 1, 8

유동적 리스트 : { [0, 0] }

x1 : 0, y1 : 0
x2 : 1, y2 : 8 --> x1 < x2 && y1 < y2 성립되어 유동 리스트의 마지막에 덧붙여 진다.

####

현재 : 2, 2

유동적 리스트 : { [0, 0], [1, 8] }

x1 : 1, y1 : 8
x2 : 2, y2 : 2 --> x1 < x2 && y1 < y2 가 성립되지 않으므로, 유동적 리스트 내부에서 들어갈 자리를 찾는다.

아까, 인덱스 1 인 (1, 8) 을 참조했으므로,

이번에는 인덱스 0 인 (0, 0) 을 참조한다.

x1 : 0, y1 : 0
x2 : 2, y2 : 2 --> x1 < x2 && y1 < y2 가 성립됨!

여기서 IDX : 0 에서 새로운 값과 비교했을 때 "조건" 이 성립했으므로,

IDX + 1 에 새로운 값 [2, 2] 로 교체한다.

그렇다면, { [0, 0], [1, 8] } ==> { [0, 0], [2, 2] }

####

현재 : 3, 9

유동적 리스트 : { [0, 0], [2, 2] }

x1 : 2, y1 : 2
x2 : 3, y2 : 9 --> x1 < x2 && y1 < y2 성립됨!

따라서, 결과적으로 유동적 리스트는 { [0, 0], [2, 2], [3, 9] } 가 되었다.

####

현재 : 4, 1

유동적 리스트 : { [0, 0], [2, 2], [3, 9] }

x1 : 3, y1 : 9
x2 : 4, y2 : 1 --> x1 < x2 && y1 < y2 가 성립되지 않음.

그렇다면, 차례로 임시 인덱스를 내려가면서 성립 될 때 까지 찾아야 한다.

IDX : 1

x1 : 2, y1 : 2
x2 : 4, y2 : 1 --> x1 < x2 && y1 < y2 가 성립되지 않음.

다시 내린다.

IDX : 0

x1 : 0, y1 : 0
x2 : 4, y2 : 1 --> x1 < x2 && y1 < y2 가 성립됨!

성립된 IDX + 1 에 [4, 1] 을 넣는다.

결과적인 유동적 리스트 : { [0, 0], [4, 1], [3, 9] }

####

현재 : 6, 4

유동적 리스트 : { [0, 0], [4, 1], [3, 9] }

x1 : 3, y1 : 9
x2 : 6, y2 : 4 --> x1 < x2 && y1 < y2 성립되지 않음.

따라서, 임시로 인덱스 생성 후 다시 하나씩 내려간다.

IDX : 1

x1 : 4, y1 : 1
x2 : 6, y2 : 4 --> x1 < x2 && y1 < y2 성립됨!

현재 배열인 [6, 4] 를, 조건이 성립된 IDX 를 기준으로, IDX + 1 에 [6, 4] 로 값을 교체하면 된다.

결과적인 유동 리스트 : { [0, 0], [4, 1], [6, 4] }

####

현재 : 7, 6

유동적 리스트 :  { [0, 0], [4, 1], [6, 4] }

x1 : 6, y1 : 4
x2 : 7, y2 : 6 --> x1 < x2 && y1 < y2 성립됨!

따라서, 현재 수인 [7, 6] 을 새롭게 뒷 부분으로 덧붙인다.

결과 : { [0, 0], [4, 1], [6, 4], [7, 6] }

####

현재 : 9, 7

유동적 리스트 : { [0, 0], [4, 1], [6, 4], [7, 6] }

x1 : 7, y1 : 6
x2 : 9, y2 : 7 --> x1 < x2 && y1 < y2 성립됨!

결과 : { [0, 0], [4, 1], [6, 4], [7, 6], [9, 7] }

####

현재 : 10, 10

유동적 리스트 : { [0, 0], [4, 1], [6, 4], [7, 6], [9, 7] }

x1 : 9, y1 : 7
x2 : 10, y2 : 10 --> x1 < x2 && y1 < y2 성립됨!

결과 : { [0, 0], [4, 1], [6, 4], [7, 6], [9, 7], [10, 10] }

결과적으로, 초기화와 누적을 위해 처음 생성해 둔 [0, 0] 만 제외하면,

정확히 필요한 전선만 없애고, 남은 전선들이 모두 살아있는 것을 볼 수 있다.

---

위의 풀이 방식으로, 구현 할 수 있는 사람들은 모두 구현이 가능 할 것이다. (혹시 보는 사람이 있다면.)

가끔 문제는 직접적으로 힌트를 주지만, 역으로 헷갈림을 만들 수도 있다는 것이다.

문제에서 제시한 것 처럼, [1, 8], [3, 9], [4, 1] 을 제거하면 최소 전선만 자른 값이 나온다.

그러나, [1, 8], [2, 2], [3, 9] 만 제거하는 것도, 최소 전선을 제거할 수 있는 방법이다.

---

그러니까, 각자의 방식대로 풀 수도 있지만, 내가 아는 방식의 LIS (최적) 방식으로는 문제에서 제시한 대로 전선을 자르지 않는다.

대신, 동일한 양의 전선을 제거하되, 대신 다른 전선을 자른다.

--

그러나, 항상 이런 식으로 트릭이 주어지는 것은 아니고, 만약에 방식이 "하나" 밖에 없다면, 결국 나의 유동적 리스트의 결과도 동일할 것이다.

다른 것이 있다면, 문제는 "잘라야 하는 최소 개수" 를 구하는 것 처럼 나온 것이고, (물론 이 시각으로도 문제를 풀 수 있습니다만,)

나의 경우는 "교차 지점이 존재하지 않는 전선의 최대 개수" 를 구하려고 하는 것이다.

결국 유동적 리스트의 결과는 { [0, 0], [4, 1], [6, 4], [7, 6], [9, 7], [10, 10] } 으로,

교차하지 않는 전선의 최대 개수는 "5개" 이다.

총 8 개의 전선에서 이 최대 개수를 빼면, 결국 없애야 하는 전깃줄의 "최소 개수" 를 구할 수 있다.

이것이 나의 풀이법이다.

*/

#include<stdio.h>

extern void* malloc(size_t byte);
extern void free(void* memory);
extern void* realloc(void* memory, size_t byte);

void temp_heap_sort(int** arrs, int len);
void heapify(int** arrs, int limit, int curr);
void swap(int** arrs, int i, int j);

int* getTwoNumber(const char* input);
void freeArrs(void** arrs);

char* intToStr(int target);
int parseInt(const char* str);
_Bool isBlank(char ch);

int main(void) {
    char input[100];

    fgets(input, sizeof(input), stdin);

    int N = parseInt(input);

    int** arrs = (int**)malloc(sizeof(int*) * (N + 2));
    *(arrs + N + 1) = NULL;

    *arrs = (int*)malloc(sizeof(int) * (2 + 1));

    *(*arrs) = *(*(arrs) + 1) = 0;

    int idx = 1;
    while(idx <= N) {
        fgets(input, sizeof(input), stdin);

        *(arrs + idx++) = getTwoNumber(input);
    }

    temp_heap_sort(arrs, N + 1);

    int size = 5;
    int currSize = 0;

    int** flexArrs = (int**)malloc(sizeof(int*) * (size + 2));
    *(flexArrs) = (int*)malloc(sizeof(int*) * (2 + 1));

    // 0 0 초기화
    *(*flexArrs) = *(*flexArrs + 1) = 0;

    idx = 1;
    while(idx <= N) {
        int* tempArr = *(arrs + idx);

        int x1 = *(*(flexArrs + currSize));
        int x2 = *tempArr;

        int y1 = *(*(flexArrs + currSize) + 1);
        int y2 = *(tempArr + 1);

        if(x1 < x2 && y1 < y2) {
            currSize++;
            int* newArr = (int*)malloc(sizeof(int) * (2 + 1));
            *newArr = x2; *(newArr + 1) = y2;

            *(flexArrs + currSize) = newArr;

            if(size == currSize) {
                size *= 2;
                flexArrs = (int**)realloc(flexArrs, sizeof(int*) * (size + 2));
            }
        } else {
            int i = currSize - 1;
            while(i >= 0) {
                int x1 = *(*(flexArrs + i));
                int y1 = *(*(flexArrs + i) + 1);

                // 루프문 내에서는 무조건 한 번은 성립할 수밖에 없다. [0, 0] 의 존재.
                if(x1 < x2 && y1 < y2) {
                    *(*(flexArrs + i + 1)) = x2;
                    *(*(flexArrs + i + 1) + 1) = y2;

                    break;
                }
                i--;
            }
        }

        idx++;
    }

    char* resultStr = intToStr(N - currSize);
    fputs(resultStr, stdout); fputc('\n', stdout);
    free(resultStr);

    freeArrs((void**)arrs);
    freeArrs((void**)flexArrs);

    return 0;
}

void temp_heap_sort(int** arrs, int len) {
    int idx = len / 2 - 1;
    while(idx >= 0) {
        heapify(arrs, len, idx--);
    }

    idx = len - 1;
    while(idx > 0) {
        swap(arrs, idx, 0);
        heapify(arrs, idx, 0);
        idx--;
    }

    return;
}
void heapify(int** arrs, int limit, int curr) {
    int parent = curr;
    int left = parent * 2 + 1;
    int right = parent * 2 + 2;

    if(left < limit && *(*(arrs + parent)) < *(*(arrs + left))) {
        parent = left;
    }
    if(right < limit && *(*(arrs + parent)) < *(*(arrs + right))) {
        parent = right;
    }

    if(parent != curr) {
        swap(arrs, parent, curr);
        heapify(arrs, limit, parent);
    }

    return;
}
void swap(int** arrs, int i, int j) {
    int* temp = *(arrs + i);
    *(arrs + i) = *(arrs + j);
    *(arrs + j) = temp;

    return;
}

int* getTwoNumber(const char* input) {
    int* arr = (int*)malloc(sizeof(int) * (2 + 1));
    *arr = 0;
    *(arr + 1) = 0;

    char* inputPtr = (char*)input;
    while(!isBlank(*inputPtr)) {
        *arr *= 10;
        *arr += *inputPtr++ - '0';
    }
    inputPtr++;
    while(!isBlank(*inputPtr)) {
        *(arr + 1) *= 10;
        *(arr + 1) += *inputPtr++ - '0';
    }

    return arr;
}
void freeArrs(void** arrs) {
    void** arrsPtr = arrs;
    while(*arrsPtr) {
        free(*arrsPtr++);
    }
    free(arrs);

    return;
}

char* intToStr(int target) {
    int sign = 1;
    int len = 0;

    if(target < 0) {
        target *= -1;
        sign = -1;
    }

    int temp = target;
    do {
        temp /= 10;
        len++;
    } while(temp != 0);

    int size = sign == 1 ? len : len + 1;
    int endIdx = size - 1;
    int startIdx = sign == 1 ? 0 : 1;

    char* result = (char*)malloc(sizeof(char) * (size + 1));
    *(result + size) = 0;

    int idx = endIdx;
    while(idx >= startIdx) {
        *(result + idx--) = (target % 10) + '0';
        target /= 10;
    }
    *result = sign == 1 ? *result : '-';

    return result;
}
int parseInt(const char* str) {
    int sign = 1;
    int result = 0;

    char* strPtr = (char*)str;
    if(*strPtr == '-') {
        sign = -1;
        strPtr++;
    }

    while(!isBlank(*strPtr)) {
        result *= 10;
        result += *strPtr++ - '0';
    }

    return result * sign;
}
_Bool isBlank(char ch) {
    if(ch == 32 || ch == 0) {
        return 1;
    } else if(ch >= 9 && ch <= 13) {
        return 1;
    } else {
        return 0;
    }
}
